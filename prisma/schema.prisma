generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Nft {
  id            Int          @id @default(autoincrement())
  dropId        Int
  name          String
  description   String
  rarity        String
  ipfsPath      String
  s3Path        String
  tags          String
  numberOfMints Int          @default(0)
  drop          Drop         @relation(name: "nftOnDrop", fields: [dropId], references: [id])
  prizeProof    PrizeProof[]
  defaultPrizes Drop[]
}

model Drop {
  id                  Int       @id @default(autoincrement())
  bannerImageName     String
  costPerTicketPoints BigInt    @default(0)
  costPerTicketCoins  Float     @default(0.0)
  dropDescription     String
  dropName            String
  endTime             String
  lotteryId           Int
  prizeMetadataCid    String
  startTime           String
  bannerImageIpfsPath String
  bannerImageS3Path   String
  metadataIpfsPath    String
  metadataS3Path      String
  tags                String
  royaltyPercentage   Float     @default(0.0)
  defaultPrizeId      Int?
  defaultPrize        Nft?      @relation(fields: [defaultPrizeId], references: [id])
  maxParticipants     Int       @default(0)
  blockchainCreatedAt DateTime?
  approvedAt          DateTime?
  approvedBy          String?   @db.Char(42)
  ApprovedBy          User?     @relation(name: "approvals", fields: [approvedBy], references: [walletAddress])
  createdAt           DateTime  @default(now())
  Nft                 Nft[]     @relation(name: "nftOnDrop")
  createdBy           String    @db.Char(42)
  CreatedBy           User      @relation(name: "artists", fields: [createdBy], references: [walletAddress])
  User                User[]    @relation(name: "userFavoriteDrops")
}

model PrizeProof {
  lotteryId     Int
  winnerAddress String    @db.Char(42)
  proof         String
  claimedAt     DateTime?
  createdAt     DateTime
  nftId         Int
  nft           Nft       @relation(fields: [nftId], references: [id])

  @@id([lotteryId, winnerAddress])
}

model MemeTransactions {
  blockNumber    Int
  blockTimestamp Int
  from           String    @db.Char(42)
  to             String    @db.Char(42)
  value          String
  assetType      AssetType
  id             Int       @id @default(autoincrement())
  txHash         String    @db.Char(66)

  @@index([from, to])
}

model RewardPublished {
  address           String   @id @db.Char(42)
  totalPointsEarned BigInt   @default(0)
  proof             String
  updatedAt         DateTime @default(now())
}

model RewardType {
  type               AssetType @id
  rewardRate         Float
  lastBlockInspected BigInt
  contract           String    @db.Char(42)
  chainId            Int
  startingBlock      BigInt
}

model User {
  walletAddress String   @id @db.Char(42)
  userName      String?
  email         String?  @unique
  createdAt     DateTime @default(now())
  role          Role     @default(USER)
  bio           String?  @db.VarChar(200)
  Approval      Drop[]   @relation(name: "approvals")
  Artist        Drop[]   @relation("artists")
  FavoriteDrop  Drop[]   @relation(name: "userFavoriteDrops")

  @@index([walletAddress])
}

enum AssetType {
  ETH_MEMEINU
  FTM_MEMEINU
  FTM_LIQUIDITY
}

enum Role {
  USER
  ARTIST
  ADMIN
}
