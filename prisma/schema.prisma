generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Nft {
  id            Int          @id @default(autoincrement())
  dropId        Int
  name          String
  description   String
  rarity        String
  ipfsPath      String
  s3Path        String
  tags          String
  numberOfMints Int          @default(0)
  isVideo       Boolean      @default(false)
  drop          Drop         @relation("nftOnDrop", fields: [dropId], references: [id])
  defaultPrizes Drop[]
  prizeProof    PrizeProof[]
}

model Drop {
  id                     Int       @id @default(autoincrement())
  bannerImageName        String
  dropDescription        String
  dropName               String
  endTime                String
  lotteryId              Int
  prizeMetadataCid       String
  startTime              String
  bannerImageIpfsPath    String
  bannerImageS3Path      String
  metadataIpfsPath       String
  metadataS3Path         String
  tags                   String
  approvedAt             DateTime?
  approvedBy             String?   @db.Char(42)
  blockchainCreatedAt    DateTime?
  costPerTicketCoins     Float     @default(0.0)
  costPerTicketPoints    BigInt    @default(0)
  createdAt              DateTime  @default(now())
  createdBy              String    @db.Char(42)
  defaultPrizeId         Int?
  isLive                 Boolean   @default(false)
  maxParticipants        Int       @default(0)
  royaltyPercentage      Float     @default(0.0)
  dropTileContentIpfsUrl String
  dropTileContentS3Url   String
  ApprovedBy             User?     @relation("approvals", fields: [approvedBy], references: [walletAddress])
  CreatedBy              User      @relation("artists", fields: [createdBy], references: [walletAddress])
  defaultPrize           Nft?      @relation(fields: [defaultPrizeId], references: [id])
  Nft                    Nft[]     @relation("nftOnDrop")
  User                   User[]    @relation("userFavoriteDrops")
}

model PrizeProof {
  lotteryId     Int
  winnerAddress String    @db.Char(42)
  proof         String
  claimedAt     DateTime?
  createdAt     DateTime
  nftId         Int
  nft           Nft       @relation(fields: [nftId], references: [id])

  @@id([lotteryId, winnerAddress, nftId])
}

model MemeTransactions {
  blockNumber    Int
  blockTimestamp Int
  from           String    @db.Char(42)
  to             String    @db.Char(42)
  value          String
  assetType      AssetType
  id             Int       @id @default(autoincrement())
  txHash         String    @db.Char(66)

  @@index([from, to])
}

model RewardPublished {
  address           String   @id @db.Char(42)
  totalPointsEarned BigInt   @default(0)
  proof             String
  updatedAt         DateTime @default(now())
}

model RewardType {
  type               AssetType @id
  rewardRate         Float
  lastBlockInspected Int
  chainId            Int
  contract           String    @db.Char(42)
  startingBlock      Int
}

model User {
  walletAddress  String   @id @db.Char(42)
  userName       String?
  email          String?  @unique
  createdAt      DateTime @default(now())
  role           Role     @default(USER)
  bio            String?  @db.VarChar(200)
  profilePicture String?
  Approval       Drop[]   @relation("approvals")
  Artist         Drop[]   @relation("artists")
  FavoriteDrop   Drop[]   @relation("userFavoriteDrops")

  @@index([walletAddress])
}

enum AssetType {
  ETH_MEMEINU
  FTM_MEMEINU
  FTM_LIQUIDITY
}

enum Role {
  USER
  ARTIST
  ADMIN
}
